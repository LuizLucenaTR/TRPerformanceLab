name: Generate Allure Report

on:
  workflow_call:
    inputs:
      results_path:
        description: 'Path to the k6 execution results'
        required: true
        type: string
      test_type:
        description: 'Type of test (load or stress)'
        required: true
        type: string

jobs:
  generate-allure-report:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          java-version: '11'
          distribution: 'temurin'
          
      - name: Install Allure CLI
        run: |
          curl -o allure-2.24.0.tgz -L https://github.com/allure-framework/allure2/releases/download/2.24.0/allure-2.24.0.tgz
          sudo tar -zxf allure-2.24.0.tgz -C /opt/
          sudo ln -s /opt/allure-2.24.0/bin/allure /usr/bin/allure
          allure --version
          
      - name: Create Allure results directory
        run: |
          mkdir -p allure-results
          mkdir -p allure-report
          
      - name: Convert k6 JSON to Allure format
        run: |
          # Install Node.js for processing JSON
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          # Create a simple converter script
          cat > convert-k6-to-allure.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          function convertK6ToAllure(k6JsonPath, allureResultsDir) {
            if (!fs.existsSync(k6JsonPath)) {
              console.log(`K6 results file not found: ${k6JsonPath}`);
              return;
            }
            
            const k6Data = fs.readFileSync(k6JsonPath, 'utf8');
            const lines = k6Data.split('\n').filter(line => line.trim());
            
            let testResults = {
              name: process.env.TEST_TYPE || 'Performance Test',
              status: 'passed',
              start: Date.now(),
              stop: Date.now(),
              uuid: generateUuid(),
              historyId: generateUuid(),
              fullName: `${process.env.TEST_TYPE || 'performance'}_test`,
              labels: [
                { name: 'suite', value: 'Performance Tests' },
                { name: 'testClass', value: process.env.TEST_TYPE || 'performance' },
                { name: 'testMethod', value: 'execute' },
                { name: 'package', value: 'k6.performance' }
              ],
              links: [],
              steps: [],
              attachments: []
            };
            
            let httpReqDurations = [];
            let httpReqFailed = 0;
            let httpReqCount = 0;
            let vus = 0;
            
            lines.forEach(line => {
              try {
                const data = JSON.parse(line);
                
                if (data.type === 'Point' && data.metric) {
                  switch (data.metric) {
                    case 'http_req_duration':
                      httpReqDurations.push(data.data.value);
                      break;
                    case 'http_req_failed':
                      if (data.data.value > 0) httpReqFailed++;
                      break;
                    case 'http_reqs':
                      httpReqCount++;
                      break;
                    case 'vus':
                      vus = Math.max(vus, data.data.value);
                      break;
                  }
                }
              } catch (e) {
                // Skip invalid JSON lines
              }
            });
            
            // Calculate statistics
            const avgDuration = httpReqDurations.length > 0 ? 
              httpReqDurations.reduce((a, b) => a + b, 0) / httpReqDurations.length : 0;
            const maxDuration = httpReqDurations.length > 0 ? Math.max(...httpReqDurations) : 0;
            const minDuration = httpReqDurations.length > 0 ? Math.min(...httpReqDurations) : 0;
            const failureRate = httpReqCount > 0 ? (httpReqFailed / httpReqCount) * 100 : 0;
            
            // Determine test status
            testResults.status = failureRate > 10 ? 'failed' : 'passed';
            testResults.statusDetails = {
              message: `Performance test completed with ${failureRate.toFixed(2)}% failure rate`,
              trace: `Requests: ${httpReqCount}, Failed: ${httpReqFailed}, Avg Duration: ${avgDuration.toFixed(2)}ms, Max VUs: ${vus}`
            };
            
            // Add steps with metrics
            testResults.steps.push({
              name: 'HTTP Request Performance',
              status: failureRate > 10 ? 'failed' : 'passed',
              start: testResults.start,
              stop: testResults.stop,
              parameters: [
                { name: 'Total Requests', value: httpReqCount.toString() },
                { name: 'Failed Requests', value: httpReqFailed.toString() },
                { name: 'Failure Rate', value: `${failureRate.toFixed(2)}%` },
                { name: 'Avg Response Time', value: `${avgDuration.toFixed(2)}ms` },
                { name: 'Min Response Time', value: `${minDuration.toFixed(2)}ms` },
                { name: 'Max Response Time', value: `${maxDuration.toFixed(2)}ms` },
                { name: 'Max Virtual Users', value: vus.toString() }
              ]
            });
            
            // Write Allure result file
            const resultFile = path.join(allureResultsDir, `${testResults.uuid}-result.json`);
            fs.writeFileSync(resultFile, JSON.stringify(testResults, null, 2));
            
            console.log(`Generated Allure result: ${resultFile}`);
            console.log(`Test Status: ${testResults.status}`);
            console.log(`Failure Rate: ${failureRate.toFixed(2)}%`);
          }
          
          function generateUuid() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
              const r = Math.random() * 16 | 0;
              const v = c == 'x' ? r : (r & 0x3 | 0x8);
              return v.toString(16);
            });
          }
          
          // Process all JSON files in results directory
          const resultsPath = process.argv[2] || 'test-results';
          const allureResultsDir = process.argv[3] || 'allure-results';
          
          fs.readdirSync(resultsPath).forEach(file => {
            if (file.endsWith('.json')) {
              convertK6ToAllure(path.join(resultsPath, file), allureResultsDir);
            }
          });
          EOF
          
          # Run the converter
          TEST_TYPE="${{ inputs.test_type }}" node convert-k6-to-allure.js "${{ inputs.results_path }}" allure-results
          
      - name: Generate Allure Report
        run: |
          # Create environment file for Allure
          cat > allure-results/environment.properties << EOF
          Test.Type=${{ inputs.test_type }}
          Target.Endpoint=${TARGET_ENDPOINT:-"Not specified"}
          Virtual.Users=${V_USERS:-"Not specified"}
          Test.Duration=${TEST_DURATION:-"Not specified"}
          Authentication=${AUTH_TYPE:-"none"}
          Execution.Time=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          GitHub.Run.ID=${{ github.run_id }}
          GitHub.Repository=${{ github.repository }}
          EOF
          
          # Generate categories file for better report organization
          cat > allure-results/categories.json << EOF
          [
            {
              "name": "Performance Issues",
              "matchedStatuses": ["failed"],
              "messageRegex": ".*performance.*"
            },
            {
              "name": "HTTP Errors",
              "matchedStatuses": ["failed"],
              "messageRegex": ".*http.*"
            }
          ]
          EOF
          
          # Generate the Allure report
          allure generate allure-results -o allure-report --clean
          
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: allure-report
          destination_dir: allure-report
          
      - name: Update Step Summary with Report Link
        run: |
          echo "## ðŸ“Š Allure Report Generated Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”— **View Report:** https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/allure-report/" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Test Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Type:** ${{ inputs.test_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Results Path:** ${{ inputs.results_path }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Generated:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> ðŸ’¡ The report will be available in a few minutes after GitHub Pages deployment completes." >> $GITHUB_STEP_SUMMARY
